#Pandas are equivalent to excel
### Creating a Series

You can convert a list,numpy array, or dictionary to a Series:

labels = ['a','b','c']
my_list = [10,20,30]
arr = np.array([10,20,30])
d = {'a':10,'b':20,'c':30}

** Using Lists**

pd.Series(data=my_list)

# Converting NumPy Arrays into series

pd.Series(numpy_array)

#Dictionary gets easily converted into series.         

pd.Series(dictionary_name)                       

### Data in a Series

pd.Series(data=labels)

# Even functions (although unlikely that you will use this)
pd.Series([sum,print,len])

## Using an Index

The key to using a Series is understanding its index. Pandas makes use of these index names or numbers by allowing for fast look ups of information (works like a hash table or dictionary).

ser1['USA']                                                      #NOTE: In series we can directly access the indices as compared to dataframes where we neede .loc or .iloc for referring to the index in dataframes the by default square bracket is for column


#Converts a Series data to dictionary data type
  s.to_dict()                                                     
















# DataFrames

from numpy.random import randn
np.random.seed(101)

## NOTE: there is only one way to manually make a dataframe ie pd.DataFrame(data,indexes,column names)
##       other ways are we can import from csv in dataframe
NOTE : even dictionaries can be used to create dataframes in pandas ..the point is key in dictionary forms the column names and index is by default 0 1 etc.

## NOTE: we always need to use inplace = True  for actually bringing any change in the dataframe

DataFrame Columns are just Series

type(df['W'])

**Creating a new column:**

df['new'] = df['W'] + df['Y']

df

** Removing Columns**

df.drop('new',axis=1)

# Not inplace unless specified!
df

df.drop('new',axis=1,inplace=True)

df

Can also drop rows this way:

df.drop('E',axis=0)

** Selecting Rows**

df.loc['A']

Or select based off of position instead of label 

df.iloc[2]

** Selecting subset of rows and columns **

df.loc['B','Y']

df.loc[['A','B'],['W','Y']]

### Conditional Selection

An important feature of pandas is conditional selection using bracket notation, very similar to numpy:

## Note : for conditional selection there is NO USE OF  ".iloc"  .we need to use iloc to slice the columns but conditional selection can be done directly and it filters the series of row values first. 
df

df>0

df[df>0]

df[df['W']>0]

df[df['W']>0]['Y']

df[df['W']>0][['Y','X']]

For two conditions you can use | and & with parenthesis:

df[(df['W']>0) & (df['Y'] > 1)]                               #Note : If we use "and" operator it only takes 2 booleans only not a series of them ....whereas with "&" operator even a series of boleans can be compared
                                                                      same is true with "or" operator as well we need to use | for comparing series of booleans        
  ## More Index Details

Let's discuss some more features of indexing, including resetting the index or setting it something else. We'll also talk about index hierarchy!

df

# Reset to default 0,1...n index
df.reset_index()


# Missing Data
d = np.nan

df = pd.DataFrame({'A':[1,2,np.nan],
                  'B':[5,np.nan,np.nan],
                  'C':[1,2,3]})

#Dropping rows or columns from a dataframe

df.dropna()
df.fillna(value='FILL VALUE')

#Appending data frame 
  pd.concat([df,y])

#Group by
  df.groupby('Company')                 #"Company" is the name of the column


